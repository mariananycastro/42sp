O(1) - constante, sempre na mesmo tempo
    tempo não muda conforme qtd data

O(n) - linear 90 graus
  tempo muda conforme qtd data

O(log n) - começa lento (poucas variaveis) mas diminui tempo - acompanha linear
  tempo muda conforme qtd data, mas diminui com aumento da qtd

O(n elevado a n) - apos um tempo é pior q o linear
  tempo muda conforme qtd data, mas piora muito rapido com aumento da qtd

Complexidade de memoria - qto de memoria eu uso

Name	                 Best Case  	Average Case  	Worst Case  	Memory	    Stable   	Method Used
Quick Sort  	          n log n	      n log n	        n^{2}	       log n	      No	      Partitioning
Merge Sort	            n log n	      n log n	      n log n	        n	          Yes	      Merging
Heap Sort	              n log n	      n log n	      n log n	        1	          No	      Selection
Insertion Sort	           n	         n^{2}        	n^{2}	        1	          Yes	      Insertion
Tim Sort	                 n	        n log n	      n log n	        n	          Yes	      Insertion & Merging
Selection Sort	         n^{2}	       n^{2}	        n^{2}	        1	          No	      Selection
Shell Sort	            n log n	      n^{4/3}	        n^{3/2}	      1	          No	      Insertion
Bubble Sort	               n	         n^{2}	        n^{2}	        1	          Yes	      Exchanging
Tree Sort	                 n log n	  n log n	      n log n	        n	          Yes	      Insertion
Cycle Sort	             n^{2}	       n^{2}	        n^{2}	        1	          No	      Selection
Strand Sort	               n	         n^{2}	        n^{2}	        n	          Yes	      Selection
Cocktail Shaker Sort	     n	         n^{2}	        n^{2}	        1	          Yes	      Exchanging
Comb Sort	              n log n	       n^{2}	        n^{2}	        1	          No	      Exchanging
Gnome Sort	               n	         n^{2}	        n^{2}	        1	          Yes	      Exchanging
Odd–even Sort	             n	         n^{2}	        n^{2}	        1	          Yes	      Exchanging

x =  (1..100).map { |z| z }
File.open("log.txt", "w") { |f| f.write x }

sa (swap a): Swap the first 2 elements at the top of stack a.
            Do nothing if there is only one or no elements.
sb (swap b): Swap the first 2 elements at the top of stack b.
            Do nothing if there is only one or no elements.
ss : sa and sb at the same time.

pa (push a): Take the first element at the top of b and put it at the top of a.
            Do nothing if b is empty.
pb (push b): Take the first element at the top of a and put it at the top of b.
            Do nothing if a is empty.

ra (rotate a): Shift up all elements of stack a by 1. The first element becomes the last one.
rb (rotate b): Shift up all elements of stack b by 1. The first element becomes the last one.
rr : ra and rb at the same time.

rra (reverse rotate a): Shift down all elements of stack a by 1. The last element becomes the first one.
rrb (reverse rotate b): Shift down all elements of stack b by 1. The last element becomes the first one.
rrr : rra and rrb at the same time.

list = ft_reverse_rotate(list);
list = ft_rotate(list);
ft_swap(list);
ft_delete_node(&list);
ft_delete_list(&list);

printf("%p - %p\n", &(list->next), list->next);